///////////////////////////////////////////////////////////////////////////// A Path-Generator//// NOTE: I don't like this saying but here it's fitting quite well://       "NEVER TOUCH A RUNING SYSTEM!"//// USES://   - General library//   - Pathfinding Libary//   - PConfig//   - PNode//   - PEdge//   - PNodeStrategy and all sub-classes//   - PGraph/////////////////////////////////////////////////////////////////////////////struct PGraphGenerator  // add a PNode to the graph by a nearby unit  private static method p_addNode takes unit u, PGraph graph returns PNode    local PNode node    local location center    local location loc = GetUnitLoc(u)    local group g = CreateGroup()    local unit indicator    local rect inner_pathingrect    local rect outer_pathingrect      //### 1. get the center of all points the node have        // '*2' cause its possible that the distance of the parameter-unit to the center is the NODERADIUS    // and we need to find the units at the otherside of the center too.    // this 'trick' generates a tradeoff between errorrate at the nodegeneration (adding wrong points)    // add flexibility for the mapper (placing the path-points)    // maybe reduce the NODERADIUS to avoid wrong nodegeneration    call GroupEnumUnitsInRangeOfLoc(g, loc, PConfig_NODERADIUS*2, PGS.getPointFilter())        set center = GroupFindCenterLoc(g)        //### 1.b if unit was a sink-indicator delete the unit, we don't need this unit anymore    if(GetUnitTypeId(u) == PConfig_UT_NODE_SINK) then      call RemoveUnit(u)    endif        //### 2. add the UT_NODE_INDICATOR to the center    set indicator = CreateUnitAtLoc(PConfig_OWNER, PConfig_UT_NODE_INDICATOR, center, 0)        //### 3. create the pathing-rects    set inner_pathingrect = MakeSimplePathingRectByUnit(indicator, PConfig_RECTSIZE_INNER)    set outer_pathingrect = MakeSimplePathingRectByUnit(indicator, PConfig_RECTSIZE_OUTER)        //### 4. create a node by the UT_NODE_INDICATOR and the pathing-rects    set node = PNode.create(PConfig_getPNodeStrategy(u), indicator, inner_pathingrect, outer_pathingrect)    call graph.addNode(node)      // clearup    call RemoveLocation(loc)    call RemoveLocation(center)    call DestroyGroup(g)    set loc = null    set center = null    set g = null    set indicator = null    set inner_pathingrect = null    set outer_pathingrect = null        return node  endmethod    // get a PNode by a nearby unit  // create it, if it isnt present  private static method p_getNode takes unit u, PGraph graph returns PNode    local PNode node    local location loc = GetUnitLoc(u)    local group g = CreateGroup()    local unit indicator        //### 1. get a UT_NODE_INDICATOR who is closed to the unit    // we only need one UT_NODE_INDICATOR    // (if there is a 2nd its an error of the system, maybe throw it here)        call GroupEnumUnitsInRangeOfLocCounted(g, loc, PConfig_NODERADIUS, PGS.getNodeIndicatorFilter(), 1)    //### 2. if non found: create it with p_addNode    //###    else: get the node with the UT_NODE_INDICATOR and return it    set indicator = FirstOfGroup(g)    if (indicator == null) then      set node = PGraphGenerator.p_addNode(u, graph)    else      set node = PNode.fromUnit(indicator)    endif        // clearup    call RemoveLocation(loc)    call DestroyGroup(g)    set loc = null    set g = null    set indicator = null    return node  endmethod    // find a PEdge _and_ set the goal PNode  private static method p_findEdge takes unit u, PGraph graph returns PEdge    //### 1. create a new edge    local unit next    local unit current = u    local integer nextut    local PEdge egde = PEdge.create(graph)    local rect inner_pathingRect    local rect outer_pathingRect    local PNode node    local PNode startNode = PGraphGenerator.p_getNode(u,graph)        //### 1. add the source point    call egde.addWaypoint(startNode.getPathingRect_Inner(), startNode.getPathingRect_Outer())        //### 2. add points to the edge by traversing from point to point through the edge by using the    //###    sight of the point    //### 3. if we find a node, add the rect and the pnode(as goal) to the path and return the path.    loop      set next = ClosestUnitInAngleofsight(current, PConfig_MAXPOINTANGLE, PConfig_NODERADIUS, PConfig_MAXPOINTRANGE, PGS.getTypedPointFilter(GetUnitTypeId(current)))          // error, no next edge-point found!      if(next == null) then        call showMessage("ERROR: can't find next EdgePoint")        call PingMinimap(GetUnitX(current), GetUnitY(current), 10)        return nill      endif          if(PConfig_isIndicatorTypeEdge(next)) then        // create a pathing rect        set inner_pathingRect = MakeSimplePathingRectByUnit(next, PConfig_RECTSIZE_INNER)        set outer_pathingRect = MakeSimplePathingRectByUnit(next, PConfig_RECTSIZE_OUTER)      else    //### 3a.  try to find a PNode at units position (search for a nearby UT_NODE_INDICATOR)    //###      if non found; create it        // add the node here (search for a nearby UT_NODE_INDICATOR)        set node = PGraphGenerator.p_getNode(next,graph)                call egde.addGoal(node)        set inner_pathingRect = node.getPathingRect_Inner()        set outer_pathingRect = node.getPathingRect_Outer()      endif            // add the point to the edge here      call egde.addWaypoint(inner_pathingRect, outer_pathingRect)      // and remove the current unit, we dont need the unit again      call RemoveUnit(current)            set current = next      // a egde only contains UT_EGDEPOINT      // except the goal-node of the edge      exitwhen not(PConfig_isIndicatorTypeEdge(next))    endloop        // clearup    set inner_pathingRect = null    set outer_pathingRect = null    set next = null    set current = null      return egde  endmethod  // add a PEdge to the graph  private static method p_addEdge takes unit u, PGraph graph returns nothing    //### 1. get the PNode at edegstart-units position (search for a nearby UT_NODE_INDICATOR)    local PNode node = PGraphGenerator.p_getNode(u,graph)        local PEdge edge    local rect pathingRect        //### 3. find the edge for the edegstart-unit    set edge = PGraphGenerator.p_findEdge(u,graph)    //### 4. add the edge to the node    call node.addEdge(edge)        // remove the edegstart-unit    call RemoveUnit(u)  endmethod  // generate the graph  public static method generate takes PGraph graph returns nothing    local group edgeStarts = CreateGroup()    local unit u        //### 1. get all edegstart-units    call GroupEnumUnitsOfPlayer(edgeStarts, PConfig_OWNER, PGS.getPathstartFilter())        //### 2. iterate over all edegstart-units    //###    and add all edges    loop      set u = FirstOfGroup(edgeStarts)      exitwhen u == null      call GroupRemoveUnit(edgeStarts, u)            // add the egde with start 'edegstart-unit'      call PGraphGenerator.p_addEdge(u,graph)    endloop        // clearup    call DestroyGroup(edgeStarts)    set edgeStarts = null  endmethodendstruct/////////////////////////////////////////////////////////////////////////////// Some problematic stuff the generator has to know about the working // enviroment. Do this stuff in the PConfig isn't nice so we do it// here ^^.//// not very fast but it do it's work and is scaleablestruct PGS  //! runtextmacro EnforceStatic("PGS")  ///////////////////////////////////////////////////  // to map a unit-type to a node-strategy  ///////////////////////////////////////////////////  private static integer array nodeStrategyIndicator  private static PNodeStrategy array nodeStrategy  private static integer nodeStrategyCount = 0    private static integer array edgeTypes  private static integer edgeTypeCount = 0  // add new informations how to map a node-orientaion or sink to a strategy  //  // this means: if find "nodeStrategyIndicator" use "nodeStrategy"  public static method addNodeStrategy takes integer nodeStrategyIndicator, PNodeStrategy nodeStrategy returns nothing    set PGS.nodeStrategyIndicator[PGS.nodeStrategyCount] = nodeStrategyIndicator    set PGS.nodeStrategy[PGS.nodeStrategyCount] = nodeStrategy    set PGS.nodeStrategyCount = PGS.nodeStrategyCount + 1  endmethod  // add new informations what an edge is  //  // this means: "edgePoint" is an edge orientaion  public static method addEdgeType takes integer edgePoint returns nothing    set PGS.edgeTypes[PGS.edgeTypeCount] = edgePoint    set PGS.edgeTypeCount = PGS.edgeTypeCount + 1  endmethod    // get the node-strategy by the unittype of this node-orientation or sink.  public static method getNodeStrategy takes integer nodeStrategyIndicator returns PNodeStrategy    local integer i = 0        loop      exitwhen i >= PGS.nodeStrategyCount          if(PGS.nodeStrategyIndicator[i] == nodeStrategyIndicator) then        return PGS.nodeStrategy[i]      endif            set i = i + 1    endloop        call showMessage("Critical Map Error: don't know is nodetype [PGS.getNodeStrategy]")    return nill  endmethod    ///////////////////////////////////////////////////  // some infos about nodes and edges  ///////////////////////////////////////////////////      // is an unittype an node-orientation or sink ?  public static method isNodeType takes integer nodeStrategyIndicator returns boolean    local integer i = 0        loop      exitwhen i >= PGS.nodeStrategyCount          if(PGS.nodeStrategyIndicator[i] == nodeStrategyIndicator) then        return true      endif            set i = i + 1    endloop    return false  endmethod    // is an unittype an edge-orientation ?  public static method isEdgeType takes integer edgePoint returns boolean    local integer i = 0        loop      exitwhen i >= PGS.edgeTypeCount          if(PGS.edgeTypes[i] == edgePoint) then        return true      endif            set i = i + 1    endloop    return false  endmethod    //////////////////////////////////////////////////////////////////////////////////  //////////////////////////////////////////////////////////////////////////////////  // FILTER  //////////////////////////////////////////////////////////////////////////////////  //////////////////////////////////////////////////////////////////////////////////    private static conditionfunc FILTER_POINT  private static conditionfunc FILTER_TYPED_POINT  private static conditionfunc FILTER_PATHSTART  private static conditionfunc FILTER_NODE_INDICATOR  private static integer currentEdgePointType    ///////////////////////////////////////////////////////////////////////////  // 'true' if matching (indicator)unit is a point of the graph  private static method p_filter_point takes nothing returns boolean    local integer ut = GetUnitTypeId(GetFilterUnit())    return PGS.isNodeType(ut) or PGS.isEdgeType(ut) or ut == PConfig_UT_NODE_INDICATOR  endmethod    public static method getPointFilter takes nothing returns conditionfunc    return PGS.FILTER_POINT  endmethod    // 'true' if matching unit is a (typed)-point of the graph  //        like 'getPointFilter' but only accept edge-points  //        of the given (indicator)unittype 'ut'  //  // WHY?:          this method is used to generate crossing-edges!  //                with this method u can match only edge-points of the  //                same type as the start of the edge, this way u ignore  //                point-(indicator)units of other edges  //                (u maybe want to place to point-(indicator)units at the same location  //                 on the map, but u like to control which one is fetched by  //                 which edge-(indicator)unit-predecessor)  //  // BE CAREFULL:   the correctness of the returned conditionfunction is only  //                garentied until the next call of this function!  //  // NOTE:          if 'ut' == PConfig_UT_NODE_DIR (the point-(indicator)unit is a start of a path),   //                this method works like 'getPointFilter'  //  private static method p_filter_typed_point takes nothing returns boolean    local integer ut = GetUnitTypeId(GetFilterUnit())    return PGS.isNodeType(ut) or ut == PGS.currentEdgePointType or ut == PConfig_UT_NODE_INDICATOR  endmethod    public static method getTypedPointFilter takes integer ut returns conditionfunc    if(ut == PConfig_UT_NODE_DIR) then      return PGS.getPointFilter()    endif        set PGS.currentEdgePointType = ut    return PGS.FILTER_TYPED_POINT  endmethod    // 'true' if matching (indicator)unit is the start of a edge  private static method p_filter_pathstart takes nothing returns boolean    return GetUnitTypeId(GetFilterUnit()) == PConfig_UT_NODE_DIR  endmethod    public static method getPathstartFilter takes nothing returns conditionfunc    return PGS.FILTER_PATHSTART  endmethod    // 'true' if matching (indicator)unit is a node indicator  // (an identifier for a node in the graph)  private static method p_filter_node_indicator takes nothing returns boolean    return GetUnitTypeId(GetFilterUnit()) == PConfig_UT_NODE_INDICATOR  endmethod    public static method getNodeIndicatorFilter takes nothing returns conditionfunc    return PGS.FILTER_NODE_INDICATOR  endmethod      ///////////////////////////////////////////////////////////////////////////  // INIT FILTERS  public static method initFilters takes nothing returns nothing    set PGS.FILTER_POINT = Condition(function PGS.p_filter_point)    set PGS.FILTER_TYPED_POINT = Condition(function PGS.p_filter_typed_point)    set PGS.FILTER_PATHSTART = Condition(function PGS.p_filter_pathstart)    set PGS.FILTER_NODE_INDICATOR = Condition(function PGS.p_filter_node_indicator)  endmethodendstruct